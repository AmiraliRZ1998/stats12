if(is.null(ncol)){
ncol <- ceiling(n/nrow)
}
}
if(!(nrow*ncol)>=n) stop("Specify nrow and/or ncol.")
m <- matrix(nrow = nrow, ncol = ncol)
m[1:n] <- 1:n
edges <- p1$edges
nodes <- p1$nodes
xwidths <- apply(m, 2, function(x){
max(unlist(lapply(dots[as.vector(x)], function(d){d$nodes$node_xmax})))
})
yheights <- apply(m, 1, function(x){
max(unlist(lapply(dots[as.vector(x)], function(d){d$nodes$node_ymax})))
})
for(i in 2:n){
if(any(dots[[i]]$nodes$name %in% p1$nodes$name)){
repthese <- dots[[i]]$nodes$name[dots[[i]]$nodes$name %in% p1$nodes$name]
names(repthese) <- paste0(repthese, ".", i)
browser()
dots[[i]]$nodes$name[match(repthese, dots[[i]]$nodes$name)] <- names(repthese)
dots[[i]]$edges$from[dots[[i]]$edges$from %in% repthese] <- names(repthese)[match(dots[[i]]$edges$from, repthese)]
dots[[i]]$edges$to[dots[[i]]$edges$to %in% repthese] <- names(repthese)[match(dots[[i]]$edges$to, repthese)]
}
thisrow <- which(apply(m, 1, function(x){any(x==i)}))
thiscol <- which(apply(m, 2, function(x){any(x==i)}))
addnodes <- dots[[i]]$nodes
addx <- sum(xwidths[0:(thiscol-1)]) + (thiscol-1)*distance_x
addnodes[c("x", "node_xmax", "node_xmin")] <- addnodes[c("x", "node_xmax", "node_xmin")] + addx
addy <- sum(yheights[0:(thisrow-1)]) + (thisrow-1)*distance_y
addnodes[c("y", "node_ymax", "node_ymin")] <- addnodes[c("y", "node_ymax", "node_ymin")] + addy
dots[[i]]$nodes <- addnodes
p1$edges <- rbind(p1$edges, dots[[m[i]]]$edges)
p1$nodes <- rbind(p1$nodes, dots[[m[i]]]$nodes)
}
return(p1)
}
p <- merge.sem_graph(mdir, mrev, mloop, mindir, mcommon, mcollider, ncol = 3, nrow = 2)
p <- merge.sem_graph(mdir, mrev, mloop, mindir, mcommon, mcollider, ncol = 3, nrow = 2)
dots[[i]]$nodes$name[match(repthese, dots[[i]]$nodes$name)] <- names(repthese)
dots[[i]]$nodes$name[match(repthese, dots[[i]]$nodes$name)] <- names(repthese)
p <- merge.sem_graph(mdir, mrev, mloop, mindir, mcommon, mcollider, ncol = 3, nrow = 2)
p <- merge.sem_graph(mdir, mrev, mloop, mindir, mcommon, mcollider, ncol = 3, nrow = 2)
dots[[i]]$edges$to %in% repthese
dots[[i]]$edges$to[dots[[i]]$edges$to %in% repthese]
dots[[i]]$edges$to
repthese
repthese <- dots[[i]]$nodes$name[dots[[i]]$nodes$name %in% p1$nodes$name]
repthese
repthese <- dots[[i]]$nodes$name[dots[[i]]$nodes$name %in% p1$nodes$name]
repthese
repthese <- dots[[i]]$nodes$name[dots[[i]]$nodes$name %in% p1$nodes$name]
repthese
merge.sem_graph <- function(..., nrow = NULL, ncol = NULL, distance_x = 1, distance_y = 1){
dots <- list(...)
n <- length(dots)
if(is.null(nrow) & is.null(ncol)){
ncol <- ceiling(sqrt(n))
nrow <- ceiling(n/ncol)
} else {
if(is.null(nrow)){
nrow <- ceiling(n/ncol)
}
if(is.null(ncol)){
ncol <- ceiling(n/nrow)
}
}
if(!(nrow*ncol)>=n) stop("Specify nrow and/or ncol.")
m <- matrix(nrow = nrow, ncol = ncol)
m[1:n] <- 1:n
edges <- p1$edges
nodes <- p1$nodes
xwidths <- apply(m, 2, function(x){
max(unlist(lapply(dots[as.vector(x)], function(d){d$nodes$node_xmax})))
})
yheights <- apply(m, 1, function(x){
max(unlist(lapply(dots[as.vector(x)], function(d){d$nodes$node_ymax})))
})
for(i in 2:n){
if(any(dots[[i]]$nodes$name %in% p1$nodes$name)){
browser()
repthese <- dots[[i]]$nodes$name[dots[[i]]$nodes$name %in% p1$nodes$name]
names(repthese) <- repthese
repthese <- paste0(repthese, ".", i)
dots[[i]]$nodes$name[match(repthese, dots[[i]]$nodes$name)] <- names(repthese)
dots[[i]]$edges$from[dots[[i]]$edges$from %in% repthese] <- names(repthese)[match(dots[[i]]$edges$from, repthese)]
dots[[i]]$edges$to[dots[[i]]$edges$to %in% repthese] <- names(repthese)[match(dots[[i]]$edges$to, repthese)]
}
thisrow <- which(apply(m, 1, function(x){any(x==i)}))
thiscol <- which(apply(m, 2, function(x){any(x==i)}))
addnodes <- dots[[i]]$nodes
addx <- sum(xwidths[0:(thiscol-1)]) + (thiscol-1)*distance_x
addnodes[c("x", "node_xmax", "node_xmin")] <- addnodes[c("x", "node_xmax", "node_xmin")] + addx
addy <- sum(yheights[0:(thisrow-1)]) + (thisrow-1)*distance_y
addnodes[c("y", "node_ymax", "node_ymin")] <- addnodes[c("y", "node_ymax", "node_ymin")] + addy
dots[[i]]$nodes <- addnodes
p1$edges <- rbind(p1$edges, dots[[m[i]]]$edges)
p1$nodes <- rbind(p1$nodes, dots[[m[i]]]$nodes)
}
return(p1)
}
p <- merge.sem_graph(mdir, mrev, mloop, mindir, mcommon, mcollider, ncol = 3, nrow = 2)
repthese <- dots[[i]]$nodes$name[dots[[i]]$nodes$name %in% p1$nodes$name]
repthese
names(repthese) <- repthese
repthese <- paste0(repthese, ".", i)
repthese
repthese
merge.sem_graph <- function(..., nrow = NULL, ncol = NULL, distance_x = 1, distance_y = 1){
dots <- list(...)
n <- length(dots)
if(is.null(nrow) & is.null(ncol)){
ncol <- ceiling(sqrt(n))
nrow <- ceiling(n/ncol)
} else {
if(is.null(nrow)){
nrow <- ceiling(n/ncol)
}
if(is.null(ncol)){
ncol <- ceiling(n/nrow)
}
}
if(!(nrow*ncol)>=n) stop("Specify nrow and/or ncol.")
m <- matrix(nrow = nrow, ncol = ncol)
m[1:n] <- 1:n
edges <- p1$edges
nodes <- p1$nodes
xwidths <- apply(m, 2, function(x){
max(unlist(lapply(dots[as.vector(x)], function(d){d$nodes$node_xmax})))
})
yheights <- apply(m, 1, function(x){
max(unlist(lapply(dots[as.vector(x)], function(d){d$nodes$node_ymax})))
})
for(i in 2:n){
if(any(dots[[i]]$nodes$name %in% p1$nodes$name)){
browser()
repthese <- dots[[i]]$nodes$name[dots[[i]]$nodes$name %in% p1$nodes$name]
names(repthese) <- repthese
repthese[] <- paste0(repthese, ".", i)
dots[[i]]$nodes$name[match(repthese, dots[[i]]$nodes$name)] <- names(repthese)
dots[[i]]$edges$from[dots[[i]]$edges$from %in% repthese] <- names(repthese)[match(dots[[i]]$edges$from, repthese)]
dots[[i]]$edges$to[dots[[i]]$edges$to %in% repthese] <- names(repthese)[match(dots[[i]]$edges$to, repthese)]
}
thisrow <- which(apply(m, 1, function(x){any(x==i)}))
thiscol <- which(apply(m, 2, function(x){any(x==i)}))
addnodes <- dots[[i]]$nodes
addx <- sum(xwidths[0:(thiscol-1)]) + (thiscol-1)*distance_x
addnodes[c("x", "node_xmax", "node_xmin")] <- addnodes[c("x", "node_xmax", "node_xmin")] + addx
addy <- sum(yheights[0:(thisrow-1)]) + (thisrow-1)*distance_y
addnodes[c("y", "node_ymax", "node_ymin")] <- addnodes[c("y", "node_ymax", "node_ymin")] + addy
dots[[i]]$nodes <- addnodes
p1$edges <- rbind(p1$edges, dots[[m[i]]]$edges)
p1$nodes <- rbind(p1$nodes, dots[[m[i]]]$nodes)
}
return(p1)
}
p <- merge.sem_graph(mdir, mrev, mloop, mindir, mcommon, mcollider, ncol = 3, nrow = 2)
repthese <- dots[[i]]$nodes$name[dots[[i]]$nodes$name %in% p1$nodes$name]
names(repthese) <- repthese
repthese[] <- paste0(repthese, ".", i)
repthese
dots[[i]]$nodes$name
dots[[i]]$nodes$name[dots[[i]]$nodes$name %in% names(repthese)]
repthese[dots[[i]]$nodes$name[dots[[i]]$nodes$name %in% names(repthese)]]
dots[[i]]$nodes$name[dots[[i]]$nodes$name %in% names(repthese)] <- repthese[dots[[i]]$nodes$name[dots[[i]]$nodes$name %in% names(repthese)]]
dots[[i]]$nodes$name
dots[[i]]$edges$from[dots[[i]]$edges$from %in% names(repthese)]
repthese[dots[[i]]$edges$from[dots[[i]]$edges$from %in% names(repthese)]]
dots[[i]]$edges$to[dots[[i]]$edges$to %in% names(repthese)]
repthese[dots[[i]]$edges$to[dots[[i]]$edges$to %in% names(repthese)]]
merge.sem_graph <- function(..., nrow = NULL, ncol = NULL, distance_x = 1, distance_y = 1){
dots <- list(...)
n <- length(dots)
if(is.null(nrow) & is.null(ncol)){
ncol <- ceiling(sqrt(n))
nrow <- ceiling(n/ncol)
} else {
if(is.null(nrow)){
nrow <- ceiling(n/ncol)
}
if(is.null(ncol)){
ncol <- ceiling(n/nrow)
}
}
if(!(nrow*ncol)>=n) stop("Specify nrow and/or ncol.")
m <- matrix(nrow = nrow, ncol = ncol)
m[1:n] <- 1:n
edges <- p1$edges
nodes <- p1$nodes
xwidths <- apply(m, 2, function(x){
max(unlist(lapply(dots[as.vector(x)], function(d){d$nodes$node_xmax})))
})
yheights <- apply(m, 1, function(x){
max(unlist(lapply(dots[as.vector(x)], function(d){d$nodes$node_ymax})))
})
for(i in 2:n){
if(any(dots[[i]]$nodes$name %in% p1$nodes$name)){
repthese <- dots[[i]]$nodes$name[dots[[i]]$nodes$name %in% p1$nodes$name]
names(repthese) <- repthese
repthese[] <- paste0(repthese, ".", i)
dots[[i]]$nodes$name[dots[[i]]$nodes$name %in% names(repthese)] <- repthese[dots[[i]]$nodes$name[dots[[i]]$nodes$name %in% names(repthese)]]
dots[[i]]$edges$from[dots[[i]]$edges$from %in% names(repthese)] <- repthese[dots[[i]]$edges$from[dots[[i]]$edges$from %in% names(repthese)]]
dots[[i]]$edges$to[dots[[i]]$edges$to %in% names(repthese)] <- repthese[dots[[i]]$edges$to[dots[[i]]$edges$to %in% names(repthese)]]
}
thisrow <- which(apply(m, 1, function(x){any(x==i)}))
thiscol <- which(apply(m, 2, function(x){any(x==i)}))
addnodes <- dots[[i]]$nodes
addx <- sum(xwidths[0:(thiscol-1)]) + (thiscol-1)*distance_x
addnodes[c("x", "node_xmax", "node_xmin")] <- addnodes[c("x", "node_xmax", "node_xmin")] + addx
addy <- sum(yheights[0:(thisrow-1)]) + (thisrow-1)*distance_y
addnodes[c("y", "node_ymax", "node_ymin")] <- addnodes[c("y", "node_ymax", "node_ymin")] + addy
dots[[i]]$nodes <- addnodes
p1$edges <- rbind(p1$edges, dots[[m[i]]]$edges)
p1$nodes <- rbind(p1$nodes, dots[[m[i]]]$nodes)
}
return(p1)
}
p <- merge.sem_graph(mdir, mrev, mloop, mindir, mcommon, mcollider, ncol = 3, nrow = 2)
plot(p)
p <- tidySEM:::merge.sem_graph(mdir, mrev, mloop, mindir, mcommon, mcollider, ncol = 3, nrow = 2, distance_x = 0, distance_y = 0)
merge.sem_graph <- function(..., nrow = NULL, ncol = NULL, distance_x = 1, distance_y = 1){
dots <- list(...)
n <- length(dots)
if(is.null(nrow) & is.null(ncol)){
ncol <- ceiling(sqrt(n))
nrow <- ceiling(n/ncol)
} else {
if(is.null(nrow)){
nrow <- ceiling(n/ncol)
}
if(is.null(ncol)){
ncol <- ceiling(n/nrow)
}
}
if(!(nrow*ncol)>=n) stop("Specify nrow and/or ncol.")
m <- matrix(nrow = nrow, ncol = ncol)
m[1:n] <- 1:n
edges <- p1$edges
nodes <- p1$nodes
xwidths <- apply(m, 2, function(x){
max(unlist(lapply(dots[as.vector(x)], function(d){d$nodes$node_xmax})))
})
yheights <- apply(m, 1, function(x){
max(unlist(lapply(dots[as.vector(x)], function(d){d$nodes$node_ymax})))
})
for(i in 2:n){
if(any(dots[[i]]$nodes$name %in% p1$nodes$name)){
repthese <- dots[[i]]$nodes$name[dots[[i]]$nodes$name %in% p1$nodes$name]
names(repthese) <- repthese
repthese[] <- paste0(repthese, ".", i)
dots[[i]]$nodes$name[dots[[i]]$nodes$name %in% names(repthese)] <- repthese[dots[[i]]$nodes$name[dots[[i]]$nodes$name %in% names(repthese)]]
dots[[i]]$edges$from[dots[[i]]$edges$from %in% names(repthese)] <- repthese[dots[[i]]$edges$from[dots[[i]]$edges$from %in% names(repthese)]]
dots[[i]]$edges$to[dots[[i]]$edges$to %in% names(repthese)] <- repthese[dots[[i]]$edges$to[dots[[i]]$edges$to %in% names(repthese)]]
}
thisrow <- which(apply(m, 1, function(x){any(x==i)}))
thiscol <- which(apply(m, 2, function(x){any(x==i)}))
addnodes <- dots[[i]]$nodes
addx <- sum(xwidths[0:(thiscol-1)]) + (thiscol-1)*distance_x
addnodes[c("x", "node_xmax", "node_xmin")] <- addnodes[c("x", "node_xmax", "node_xmin")] + addx
addy <- sum(yheights[0:(thisrow-1)]) + (thisrow-1)*distance_y
addnodes[c("y", "node_ymax", "node_ymin")] <- addnodes[c("y", "node_ymax", "node_ymin")] + addy
dots[[i]]$nodes <- addnodes
p1$edges <- rbind(p1$edges, dots[[m[i]]]$edges)
p1$nodes <- rbind(p1$nodes, dots[[m[i]]]$nodes)
}
return(p1)
}
p <- merge.sem_graph(mdir, mrev, mloop, mindir, mcommon, mcollider, ncol = 3, nrow = 2, distance_x = 0, distance_y = 0)
plot(p)
plot(mcommon)
plot(mindir)
plot(mloop)
plot(mrew)
plot(mrev)
plot(mcollider)
# model_colliders (revised)
mcollider <- prepare_graph(dagitty::dagitty("dag{
A -> B;
C -> B
}"), layout = get_layout("", "C", "",
"A", "", "B", rows = 2))
plot(mcollider)
plot(mcollider)
mcollider <- prepare_graph(dagitty::dagitty("dag{
A -> B;
C -> B
}"), layout = get_layout("A", "", "C",
"", "B", "", rows = 2))
plot(mcollider)
mcollider <- prepare_graph(dagitty::dagitty("dag{
A -> B;
C -> B
}"), layout = get_layout("A", "", "C",
"", "B", "", rows = 2), angle = 179)
plot(mcollider)
mcollider <- prepare_graph(dagitty::dagitty("dag{
A -> B;
C -> B
}"), layout = get_layout("A", "", "C",
"", "B", "", rows = 2), angle = 0)
plot(mcollider)
# A <- B
# }"), layout = get_layout("A", "B", "C", rows = 1))
# model_direct (revised)
mdir <- prepare_graph(dagitty::dagitty("dag{
A -> B
}"), layout = get_layout("A", "B", "C", rows = 1))
# model_indirect (revised)
mindir <- prepare_graph(dagitty::dagitty("dag{
A -> B;
B -> C
}"), layout = get_layout("", "B", "",
"A", "", "C", rows = 2), angle = 179)
# model_common_cause (revised)
mcommon <- prepare_graph(dagitty::dagitty("dag{
C -> A;
C -> B
}"), layout = get_layout("", "C", "",
"A", "", "B", rows = 2), angle = 179)
# model_colliders (revised)
mcollider <- prepare_graph(dagitty::dagitty("dag{
A -> B;
C -> B
}"), layout = get_layout("A", "", "C",
"", "B", "", rows = 2), angle = 179)
# model_reverse_causation (revised)
mrev <- prepare_graph(dagitty::dagitty("dag{
B -> A
}"))
# model_feedback_loop (revised)
mloop <- prepare_graph(dagitty::dagitty("dag{
A -> B;
B -> A
}"), angle = 1, layout = get_layout("A", "B", rows = 1))
mloop$edges$curvature <- 60
mloop$edges$connect_from <- c("bottom", "top")[2:1]
mloop$edges$connect_to <- c("bottom", "top")[2:1]
p <- merge.sem_graph(mdir, mrev, mloop, mindir, mcommon, mcollider, ncol = 3, nrow = 2, distance_x = 0, distance_y = 0)
plot(p)
library(dagitty)
library(tidySEM)
# p1 <- prepare_graph(dagitty::dagitty("dag{A -> B}"), layout = get_layout("A", "B", "C", rows = 1))
#
# p2 <- prepare_graph(dagitty::dagitty("dag{
# A <- B
# }"), layout = get_layout("A", "B", "C", rows = 1))
# model_direct (revised)
mdir <- prepare_graph(dagitty::dagitty("dag{
A -> B
}"), layout = get_layout("A", "B", "C", rows = 1))
# model_indirect (revised)
mindir <- prepare_graph(dagitty::dagitty("dag{
A -> B;
B -> C
}"), layout = get_layout("", "B", "",
"A", "", "C", rows = 2), angle = 179)
# model_common_cause (revised)
mcommon <- prepare_graph(dagitty::dagitty("dag{
B -> A;
B -> C
}"), layout = get_layout("", "B", "",
"A", "", "C", rows = 2), angle = 179)
# model_colliders (revised)
mcollider <- prepare_graph(dagitty::dagitty("dag{
A -> B;
C -> B
}"), layout = get_layout("A", "", "C",
"", "B", "", rows = 2), angle = 179)
# model_reverse_causation (revised)
mrev <- prepare_graph(dagitty::dagitty("dag{
B -> A
}"))
# model_feedback_loop (revised)
mloop <- prepare_graph(dagitty::dagitty("dag{
A -> B;
B -> A
}"), angle = 1, layout = get_layout("A", "B", rows = 1))
mloop$edges$curvature <- 60
mloop$edges$connect_from <- c("bottom", "top")[2:1]
mloop$edges$connect_to <- c("bottom", "top")[2:1]
p <- merge.sem_graph(mdir, mrev, mloop, mindir, mcommon, mcollider, ncol = 3, nrow = 2, distance_x = 0, distance_y = 0)
plot(p)
knitr::opts_chunk$set(echo = FALSE)
library(ggplot2)
pbivar <- merge.sem_graph(mdir, mrev, mloop, ncol = 3, nrow = 1, distance_x = 0, distance_y = 0)
plot(pbivar)
ptri <- merge.sem_graph(mcommon, mindir, mcollider, ncol = 3, nrow = 1, distance_x = 0, distance_y = 0)
plot(ptri)
mcommon
plot(mcommon)
ptri <- merge.sem_graph(mcommon, mindir, mcollider, ncol = 3, nrow = 1, distance_x = 0, distance_y = 0)
plot(ptri)
rm(p1)
merge.sem_graph <- function(..., nrow = NULL, ncol = NULL, distance_x = 1, distance_y = 1){
dots <- list(...)
n <- length(dots)
if(is.null(nrow) & is.null(ncol)){
ncol <- ceiling(sqrt(n))
nrow <- ceiling(n/ncol)
} else {
if(is.null(nrow)){
nrow <- ceiling(n/ncol)
}
if(is.null(ncol)){
ncol <- ceiling(n/nrow)
}
}
if(!(nrow*ncol)>=n) stop("Specify nrow and/or ncol.")
m <- matrix(nrow = nrow, ncol = ncol)
m[1:n] <- 1:n
edges <- dots[[1]]$edges
nodes <- dots[[1]]$nodes
xwidths <- apply(m, 2, function(x){
max(unlist(lapply(dots[as.vector(x)], function(d){d$nodes$node_xmax})))
})
yheights <- apply(m, 1, function(x){
max(unlist(lapply(dots[as.vector(x)], function(d){d$nodes$node_ymax})))
})
for(i in 2:n){
if(any(dots[[i]]$nodes$name %in% dots[[1]]$nodes$name)){
repthese <- dots[[i]]$nodes$name[dots[[i]]$nodes$name %in% dots[[1]]$nodes$name]
names(repthese) <- repthese
repthese[] <- paste0(repthese, ".", i)
dots[[i]]$nodes$name[dots[[i]]$nodes$name %in% names(repthese)] <- repthese[dots[[i]]$nodes$name[dots[[i]]$nodes$name %in% names(repthese)]]
dots[[i]]$edges$from[dots[[i]]$edges$from %in% names(repthese)] <- repthese[dots[[i]]$edges$from[dots[[i]]$edges$from %in% names(repthese)]]
dots[[i]]$edges$to[dots[[i]]$edges$to %in% names(repthese)] <- repthese[dots[[i]]$edges$to[dots[[i]]$edges$to %in% names(repthese)]]
}
thisrow <- which(apply(m, 1, function(x){any(x==i)}))
thiscol <- which(apply(m, 2, function(x){any(x==i)}))
addnodes <- dots[[i]]$nodes
addx <- sum(xwidths[0:(thiscol-1)]) + (thiscol-1)*distance_x
addnodes[c("x", "node_xmax", "node_xmin")] <- addnodes[c("x", "node_xmax", "node_xmin")] + addx
addy <- sum(yheights[0:(thisrow-1)]) + (thisrow-1)*distance_y
addnodes[c("y", "node_ymax", "node_ymin")] <- addnodes[c("y", "node_ymax", "node_ymin")] + addy
dots[[i]]$nodes <- addnodes
dots[[1]]$edges <- rbind(dots[[1]]$edges, dots[[m[i]]]$edges)
dots[[1]]$nodes <- rbind(dots[[1]]$nodes, dots[[m[i]]]$nodes)
}
return(dots[[1]])
}
pbivar <- merge.sem_graph(mdir, mrev, mloop, ncol = 3, nrow = 1, distance_x = 0, distance_y = 0)
ptri <- merge.sem_graph(mcommon, mindir, mcollider, ncol = 3, nrow = 1, distance_x = 0, distance_y = 0)
plot(ptri)
merge.sem_graph <- function(..., nrow = NULL, ncol = NULL, distance_x = 1, distance_y = 1){
dots <- list(...)
n <- length(dots)
if(is.null(nrow) & is.null(ncol)){
ncol <- ceiling(sqrt(n))
nrow <- ceiling(n/ncol)
} else {
if(is.null(nrow)){
nrow <- ceiling(n/ncol)
}
if(is.null(ncol)){
ncol <- ceiling(n/nrow)
}
}
if(!(nrow*ncol)>=n) stop("Specify nrow and/or ncol.")
m <- matrix(nrow = nrow, ncol = ncol)
m[1:n] <- 1:n
edges <- dots[[1]]$edges
nodes <- dots[[1]]$nodes
xwidths <- apply(m, 2, function(x){
max(unlist(lapply(dots[as.vector(x)], function(d){d$nodes$node_xmax})))
})
yheights <- apply(m, 1, function(x){
max(unlist(lapply(dots[as.vector(x)], function(d){d$nodes$node_ymax})))
})
for(i in 2:n){
if(any(dots[[i]]$nodes$name %in% dots[[1]]$nodes$name)){
repthese <- dots[[i]]$nodes$name[dots[[i]]$nodes$name %in% dots[[1]]$nodes$name]
names(repthese) <- repthese
repthese[] <- paste0(repthese, ".", i)
dots[[i]]$nodes$name[dots[[i]]$nodes$name %in% names(repthese)] <- repthese[dots[[i]]$nodes$name[dots[[i]]$nodes$name %in% names(repthese)]]
dots[[i]]$edges$from[dots[[i]]$edges$from %in% names(repthese)] <- repthese[dots[[i]]$edges$from[dots[[i]]$edges$from %in% names(repthese)]]
dots[[i]]$edges$to[dots[[i]]$edges$to %in% names(repthese)] <- repthese[dots[[i]]$edges$to[dots[[i]]$edges$to %in% names(repthese)]]
}
thisrow <- which(apply(m, 1, function(x){any(x==i)}))
thiscol <- which(apply(m, 2, function(x){any(x==i)}))
addnodes <- dots[[i]]$nodes
addx <- sum(xwidths[0:(thiscol-1)]) + (thiscol-1)*distance_x
addnodes[c("x", "node_xmax", "node_xmin")] <- addnodes[c("x", "node_xmax", "node_xmin")] + addx
addy <- sum(yheights[0:(thisrow-1)]) + (thisrow-1)*distance_y
addnodes[c("y", "node_ymax", "node_ymin")] <- addnodes[c("y", "node_ymax", "node_ymin")] + addy
dots[[i]]$nodes <- addnodes
dots[[1]]$edges <- rbind(dots[[1]]$edges, dots[[m[i]]]$edges)
dots[[1]]$nodes <- rbind(dots[[1]]$nodes, dots[[m[i]]]$nodes)
}
return(dots[[1]])
}
ptri <- merge.sem_graph(mcommon, mindir, mcollider, ncol = 3, nrow = 1, distance_x = 0, distance_y = 0)
plot(ptri)
ptri <- merge.sem_graph(mcommon, mindir, mcollider, ncol = 3, nrow = 1, distance_x = 0, distance_y = 0)
plot(ptri)
x <- rnorm(100)
y1 <- .4*x + rnorm(100, sd = .6)
y2 <- .7*x + rnorm(100, sd = .3)
lm(y1 ~ y2)
summary(lm(y1 ~ y2))
summary(lm(y1 ~ B+y2))
summary(lm(y1 ~ X+y2))
summary(lm(y1 ~ x+y2))
summary(lm(y1 ~ x))
pbivar$nodes$shape
pbivar$nodes$shape <- "square"
plot(pbivar)
pbivar$nodes
pbivar$nodes$shape <- "rect"
plot(pbivar)
ptri$nodes$shape <- "rect"
plot(ptri)
remotes::install_github("cjvanlissa/tidySEM")
